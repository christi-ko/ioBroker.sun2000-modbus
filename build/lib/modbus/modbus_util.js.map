{
  "version": 3,
  "sources": ["../../../src/lib/modbus/modbus_util.ts"],
  "sourcesContent": ["import ModbusRTU from \"modbus-serial\"\nimport \"buffer\";\nimport {ModbusDatatype} from \"./modbus_types\";\nimport log from \"loglevel\";\n\nlog.setLevel(log.levels.WARN);\n\nexport class ModbusConnection {\n    private client: ModbusRTU;\n    private readonly ipAddress: string;\n    private readonly port: number;\n    private readonly clientId: number;\n\n    constructor(ipAddress: string, port: number, clientId: number) {\n        this.ipAddress = ipAddress;\n        this.port = port;\n        this.clientId = clientId;\n        this.client = new ModbusRTU();\n    }\n\n    async open() {\n        // @ts-ignore\n        if (!this.client.isOpen) {\n            await this.expoBackoffConnect(2000, 20000);\n        }\n    }\n\n    isOpen(): boolean {\n        // @ts-ignore\n        return this.client.isOpen;\n    }\n\n    close() {\n        // @ts-ignore\n        this.client.close(()=>{});\n    }\n\n    /**\n     * read Holding Register (HR) from Modbus device\n     * @param register decimal Modbus Register to read\n     * @param dtype Datatype like signed or unsigned integer\n     * @param length Number of occupied Modbus registers\n     * @returns converted value from Register\n     * @throws error\n     */\n    async readModbusHR(register: number, dtype: ModbusDatatype, length?: number): Promise<any> {\n        let words = ModbusDatatype.words(dtype);\n        if (length != undefined) {\n            words = length;\n        }\n        if (words == undefined) {\n            throw new Error(\"A dtype with undefined length cant be used without passing a custom length!\")\n        }\n        if (!this.isOpen()) {\n            await this.open();\n        }\n        log.info(\"Length: \" + words);\n        let answer = await this.client.readHoldingRegisters(register, words);\n        log.debug(`Answer: ${answer}`);\n        return ModbusDatatype.fromBuffer(dtype, answer.buffer);\n    }\n\n    /**\n     * read Input Register (IR) from Modbus device\n     * @param register decimal Modbus Register to read\n     * @param dtype Datatype like signed or unsigned integer\n     * @param length Number of occupied Modbus registers\n     * @returns readable value from Register\n     * @throws error\n     */\n    async readModbusIR(register: number, dtype: ModbusDatatype, length?: number): Promise<any> {\n        let words = ModbusDatatype.words(dtype);\n        if (length != undefined) {\n            words = length;\n        }\n        if (words == undefined) {\n            throw new Error(\"A dtype with undefined length cant be used without passing a custom length!\")\n        }\n        if (!this.isOpen()) {\n            await this.open();\n        }\n        log.info(\"Length: \" + words);\n        let answer = await this.client.readInputRegisters(register, words);\n        log.debug(answer);\n        return ModbusDatatype.fromBuffer(dtype, answer.buffer);\n    }\n\n    private async expoBackoffConnect(delay: number, maxDelay: number): Promise<any> {\n        try {\n            this.close();\n            this.client = new ModbusRTU();\n            this.client.setID(this.clientId);\n            await this.client.connectTcpRTUBuffered(this.ipAddress, {port: this.port});\n            await this.asyncTimeout(delay);\n            log.info(\"Connected to \" + this.ipAddress);\n        } catch (e) {\n            log.warn(\"Couldnt connect to \" + this.ipAddress + \":\" + this.port);\n            let nextDelay = delay * 2;\n            if (nextDelay > maxDelay) {\n                nextDelay = maxDelay;\n            }\n            await this.asyncTimeout(nextDelay);\n            await this.expoBackoffConnect(nextDelay, maxDelay)\n        }\n    }\n\n    private asyncTimeout(ms: number) {\n        return new Promise(resolve => setTimeout(resolve, ms))\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAAsB;AACtB,oBAAO;AACP,0BAA6B;AAC7B,sBAAgB;AAEhB,gBAAAA,QAAI,SAAS,gBAAAA,QAAI,OAAO,IAAI;AAErB,MAAM,iBAAiB;AAAA,EAM1B,YAAY,WAAmB,MAAc,UAAkB;AAC3D,SAAK,YAAY;AACjB,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,SAAS,IAAI,qBAAAC,QAAU;AAAA,EAChC;AAAA,EAEA,MAAM,OAAO;AAET,QAAI,CAAC,KAAK,OAAO,QAAQ;AACrB,YAAM,KAAK,mBAAmB,KAAM,GAAK;AAAA,IAC7C;AAAA,EACJ;AAAA,EAEA,SAAkB;AAEd,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EAEA,QAAQ;AAEJ,SAAK,OAAO,MAAM,MAAI;AAAA,IAAC,CAAC;AAAA,EAC5B;AAAA,EAUA,MAAM,aAAa,UAAkB,OAAuB,QAA+B;AACvF,QAAI,QAAQ,mCAAe,MAAM,KAAK;AACtC,QAAI,UAAU,QAAW;AACrB,cAAQ;AAAA,IACZ;AACA,QAAI,SAAS,QAAW;AACpB,YAAM,IAAI,MAAM,6EAA6E;AAAA,IACjG;AACA,QAAI,CAAC,KAAK,OAAO,GAAG;AAChB,YAAM,KAAK,KAAK;AAAA,IACpB;AACA,oBAAAD,QAAI,KAAK,aAAa,KAAK;AAC3B,QAAI,SAAS,MAAM,KAAK,OAAO,qBAAqB,UAAU,KAAK;AACnE,oBAAAA,QAAI,MAAM,WAAW,QAAQ;AAC7B,WAAO,mCAAe,WAAW,OAAO,OAAO,MAAM;AAAA,EACzD;AAAA,EAUA,MAAM,aAAa,UAAkB,OAAuB,QAA+B;AACvF,QAAI,QAAQ,mCAAe,MAAM,KAAK;AACtC,QAAI,UAAU,QAAW;AACrB,cAAQ;AAAA,IACZ;AACA,QAAI,SAAS,QAAW;AACpB,YAAM,IAAI,MAAM,6EAA6E;AAAA,IACjG;AACA,QAAI,CAAC,KAAK,OAAO,GAAG;AAChB,YAAM,KAAK,KAAK;AAAA,IACpB;AACA,oBAAAA,QAAI,KAAK,aAAa,KAAK;AAC3B,QAAI,SAAS,MAAM,KAAK,OAAO,mBAAmB,UAAU,KAAK;AACjE,oBAAAA,QAAI,MAAM,MAAM;AAChB,WAAO,mCAAe,WAAW,OAAO,OAAO,MAAM;AAAA,EACzD;AAAA,EAEA,MAAc,mBAAmB,OAAe,UAAgC;AAC5E,QAAI;AACA,WAAK,MAAM;AACX,WAAK,SAAS,IAAI,qBAAAC,QAAU;AAC5B,WAAK,OAAO,MAAM,KAAK,QAAQ;AAC/B,YAAM,KAAK,OAAO,sBAAsB,KAAK,WAAW,EAAC,MAAM,KAAK,KAAI,CAAC;AACzE,YAAM,KAAK,aAAa,KAAK;AAC7B,sBAAAD,QAAI,KAAK,kBAAkB,KAAK,SAAS;AAAA,IAC7C,SAAS,GAAP;AACE,sBAAAA,QAAI,KAAK,wBAAwB,KAAK,YAAY,MAAM,KAAK,IAAI;AACjE,UAAI,YAAY,QAAQ;AACxB,UAAI,YAAY,UAAU;AACtB,oBAAY;AAAA,MAChB;AACA,YAAM,KAAK,aAAa,SAAS;AACjC,YAAM,KAAK,mBAAmB,WAAW,QAAQ;AAAA,IACrD;AAAA,EACJ;AAAA,EAEQ,aAAa,IAAY;AAC7B,WAAO,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AAAA,EACzD;AACJ;",
  "names": ["log", "ModbusRTU"]
}
